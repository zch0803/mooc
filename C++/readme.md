## 桶排序
桶排序是一种O(N)的算法，但是其缺点在于所占用的空间太大，当要排序的数字值很大时，无法开出与之相同大小的数组，因此无法很好的应用，代码见tongsort.cpp实现了一个简单的桶排序。
## 冒泡排序
冒泡排序是一种O(N2)的算法，是最基础的排序算法，其缺点在于复杂度较高，其算法基本思想为通过两两比较先确定最大的数字，接着再确定第二大的数字，以此类推，因为只需要比较n-1次，因此第一重循环次数为n-1；第二重循环次数为n-1-i，其中i为已经排序好的元素个数，代码实现见bubblesort.cpp
## 快速排序
快速排序是一种O(NlogN)的算法，是较好的排序算法，其中心思想问，先找一个数，将其作为标志值，然后从左边和右边开始，分别寻找比它小和大的数，将比它大的数放在右边，比它小的数放在左边，当左右两边的寻找指针相遇时，将相遇的坐标点的值和开始的标志值进行更换，这时标志值两边的点右边的比它大，左边的比它小，然后进行递归排序就可以了。代码实现见quicksort.cpp,在实现过程中发现了问题，就是while循环中，如果使用i，j寻找值时不加等号的话，只能对没有重复数值的序列进行排序，而且最后还要对i，j是否在边界进行判断，因此在注释写明了最好的写法。
##队列的实现
队列是先进先出的数据结构，在queue.cpp中定义了一个队列的类，其中使用数组实现队列，最大长度为1000，要解决的问题为求解QQ号，即给出一个加密QQ号，解密方法为第一个数弹出后，将第二数移动到最后，如此循环，直到将所有数弹出就得到了正确的QQ号。
##栈的实现
栈是一种先进后出的数据结构，在stock.cpp中实现了栈的数据结构，其目的在于解决判断一个字符串是否是回文数。
##链表的实现
链表是C和C++特有的数据结构，需要利用指针的连接来实现，其优点在于插入数据时不需要进行数据的搬移，只需要更换指针就可以实现。list.cpp中我自己实现了一个链表的类，可以通过insert，append，del函数对其进行插入，删除，增加操作，在实现过程中，有以下几点心得：
* 实现链表的过程中一定要注意对内存的访问，很容易出现越界的情况，特别是使用next访问下一个元素的时候，要对该元素是否存在进行判定
* 链表需要head对链表头进行记录，需要一个变量记录要加入的值，需要一个变量记录现在访问的值，有时还需要一个变量记录访问值的前一个值，当然如果是双向链表可以不用记录这个值
* 要注意链表边界情况的访问，程序经常可能在边界上出现问题。
##暴力的枚举算法
枚举是程序中很常见的一种思想，但是为了在有限的时间内得到结果，必须认真分析所给的题目，找到枚举的范围，这个范围肯定是越小越好。本次示例为火柴棍等式，即有n个火柴棍，想要拼出A+B=C的形式，其中0123456789分别需要6255456376个火柴，n<=24，求问有多少个等式。此题乍一看很容易解，只要暴力枚举就可以了，但是枚举的范围却很难确定，我想了半天也没有想到，看来参考答案以后豁然开朗。因为m<=24，而+和=需要4根火柴，所以可以用于数字的火柴为20根，20根火柴最多可以拼10个1，因此每一位数字最大就是1111，所以枚举范围就是0-1111，这个推演过程是不是很精彩，实现见matchequal.cpp
##深度优先搜索
深度优先搜索的思想为从一个点开始，不断向下尝试，当遇到障碍或者搜索到底后退回去，接着尝试其他可能，**其重点在于退回去这一步非常关键。** 本次实现的两个题目为求一个n位数字的全排列和迷宫问题。具体见代码permutations.cpp和maze.cpp
##广度优先搜索
到达一个节点后，将此节点后面所有的可能全都遍历一遍，并记录下来，然后继续往下搜索，直至搜索到目标节点，仍然使用迷宫题目进行实现。在解决问题时，如果深度搜索时退回的值不修改他们已经被访问过的记录情况下， 这时候深度搜索等同于广度搜索，这种情况下，相当于是遍历每一个节点，然后遍历每一个节点的子节点，访问过的节点不会再有第二次方位机会，这种情况见island.cpp，解决了一个寻找陆地的问题。
