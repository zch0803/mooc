## 桶排序
桶排序是一种O(N)的算法，但是其缺点在于所占用的空间太大，当要排序的数字值很大时，无法开出与之相同大小的数组，因此无法很好的应用，代码见tongsort.cpp实现了一个简单的桶排序。
## 冒泡排序
冒泡排序是一种O(N2)的算法，是最基础的排序算法，其缺点在于复杂度较高，其算法基本思想为通过两两比较先确定最大的数字，接着再确定第二大的数字，以此类推，因为只需要比较n-1次，因此第一重循环次数为n-1；第二重循环次数为n-1-i，其中i为已经排序好的元素个数，代码实现见bubblesort.cpp
## 快速排序
快速排序是一种O(NlogN)的算法，是较好的排序算法，其中心思想问，先找一个数，将其作为标志值，然后从左边和右边开始，分别寻找比它小和大的数，将比它大的数放在右边，比它小的数放在左边，当左右两边的寻找指针相遇时，将相遇的坐标点的值和开始的标志值进行更换，这时标志值两边的点右边的比它大，左边的比它小，然后进行递归排序就可以了。代码实现见quicksort.cpp,在实现过程中发现了问题，就是while循环中，如果使用i，j寻找值时不加等号的话，只能对没有重复数值的序列进行排序，而且最后还要对i，j是否在边界进行判断，因此在注释写明了最好的写法。
#队列的实现
队列是先进先出的数据结构，在queue.cpp中定义了一个队列的类，其中使用数组实现队列，最大长度为1000，要解决的问题为求解QQ号，即给出一个加密QQ号，解密方法为第一个数弹出后，将第二数移动到最后，如此循环，直到将所有数弹出就得到了正确的QQ号。
#栈的实现
栈是一种先进后出的数据结构，在stock.cpp中实现了栈的数据结构，其目的在于解决判断一个字符串是否是回文数。
#链表的实现
链表是C和C++特有的数据结构，需要利用指针的连接来实现，其优点在于插入数据时不需要进行数据的搬移，只需要更换指针就可以实现。list.cpp中我自己实现了一个链表的类，可以通过insert，append，del函数对其进行插入，删除，增加操作，在实现过程中，有以下几点心得：
* 实现链表的过程中一定要注意对内存的访问，很容易出现越界的情况，特别是使用next访问下一个元素的时候，要对该元素是否存在进行判定
* 链表需要head对链表头进行记录，需要一个变量记录要加入的值，需要一个变量记录现在访问的值，有时还需要一个变量记录访问值的前一个值，当然如果是双向链表可以不用记录这个值
* 要注意链表边界情况的访问，程序经常可能在边界上出现问题。
